import pjson from '../package.json' with { type: 'json' };
import manifest from '../src/extension/meta/oclif.manifest.json' with { type: 'json' };
import shortDescriptions from './short-descriptions.json' with { type: 'json' };
import fs from 'node:fs/promises';

/**
 * Map used to match the root prefix of a
 * command to the context value of the menu item
 * that should be used to group the command in the menu.
 *
 * Adding items here will automatically add the
 * command to the menu and group it under the
 * specified context value.
 */
const prefixToContextValue = {
  apps: 'heroku:app',
  ps: 'heroku:dyno',
  pg: 'heroku:addon:heroku-postgresql',
  redis: 'heroku:addon:heroku-redis',
  addons: 'heroku:addon',
  pipelines: 'heroku:pipeline',
  spaces: 'heroku:space',
  teams: 'heroku:team'
};
const registryNamePrefix = 'heroku:user';
/**
 * Map of menu items
 */
const menuItemMap = new Map();
/**
 * Map of submenus
 */
const submenuMap = new Map();
/**
 * Retain the exiting menu items.
 * Keys generated by this script overwrite
 * existing values
 */
for (const menuItem of pjson.contributes.menus['view/item/context']) {
  const { command, group } = menuItem;
  if (command) {
    menuItemMap.set(`${command}:${group}`, menuItem);
  }
}
/**
 * Map of menu items belonging to
 * a submenu
 */
const submenuItemMap = new Map();
/**
 * Retain the exiting submenus.
 * Keys generated by this script overwrite
 * existing values
 */
for (const submenuName in pjson.contributes.menus) {
  if (submenuName === 'view/item/context') {
    continue;
  }
  const submenu = pjson.contributes.menus[submenuName];
  submenuItemMap.set(submenuName, new Map(submenu.map((sm) => [sm.command, sm])));
}
/**
 * Map of user facing commannds.
 * All commands in the oclif.manifest.json
 * are included.
 */
const commandMap = new Map();
/**
 * Perserve existing commands. Keys generated
 * by this script overwrite existing values
 */
for (const command of pjson.contributes.commands) {
  const { command: cmd } = command;
  commandMap.set(cmd, command);
}

/**
 * Iterates the commands in the oclif.manifest.json
 * and generates the menu items and submenus for the
 * commands.
 */
for (let commandId in manifest.commands) {
  if (!shortDescriptions[commandId]) {
    continue;
  }

  // Split the command topic at the colon
  // topics with a depth of 3 or more
  // will be placd in a submenu
  const parts = commandId.split(':');
  const prefix = parts[0];
  // This key is used to register the command
  // in vscode and map the menu item to the command.
  const commandKey = `${registryNamePrefix}:${commandId}`;

  // All commands in the manifest are added.
  commandMap.set(commandKey, {
    command: commandKey,
    category: `Heroku ${prefix}`,
    title: shortDescriptions[commandId] ?? ''
  });

  // The context value
  // @see https://code.visualstudio.com/api/references/vscode-api#TreeItem
  const contextValue = prefixToContextValue[prefix];
  if (!contextValue) {
    continue;
  }
  const menuItem = {
    command: commandKey,
    group: prefix,
    when: `viewItem =~ /^(${contextValue})/`
  };

  // Build the submenu for items with a topic depth of 2+
  for (let i = 2; i < parts.length; i++) {
    const part = parts[i - 1];
    const submenuLabel = part.slice(0, 1).toUpperCase() + part.slice(1);

    const prefix = parts.slice(0, i).join(':');
    const submenuKey = `heroku:submenu:${prefix}`;

    const submenuCommandMap = submenuItemMap.get(submenuKey) ?? new Map();
    submenuCommandMap.set(menuItem.command, menuItem);
    submenuItemMap.set(submenuKey, submenuCommandMap);

    submenuMap.set(submenuKey, {
      id: submenuKey,
      label: submenuLabel
    });
  }

  // Be sure to add the root topic to the submenu
  if (parts.length > 2) {
    const rootTopicCommandId = parts.slice(0, 2).join(':');
    if (manifest.commands[rootTopicCommandId]) {
      const commandKey = `${registryNamePrefix}:${rootTopicCommandId}`;
      const prefix = parts.slice(0, 2).join(':');
      const submenuKey = `heroku:submenu:${prefix}`;

      const submenuCommandMap = submenuItemMap.get(submenuKey);
      submenuCommandMap.set(commandKey, {
        command: commandKey,
        when: `viewItem =~ /^(${contextValue})/`,
        group: 'heroku@context'
      });
    }
  }

  // Everything else.
  if (parts.length < 3) {
    menuItemMap.set(`${menuItem.command}:${menuItem.group}`, menuItem);
  }
}

pjson.contributes.commands = Array.from(commandMap.values());
pjson.contributes.menus['view/item/context'] = Array.from(menuItemMap.values());
submenuMap.forEach((value, key) => {
  pjson.contributes.menus['view/item/context'].push({
    submenu: key
  });
});
submenuItemMap.forEach((value, key) => {
  pjson.contributes.menus[key] = Array.from(value.values());
});
pjson.contributes.submenus = Array.from(submenuMap.values());
await fs.writeFile('package.json', JSON.stringify(pjson, null, 2));
