import pjson from '../package.json' with { type: 'json' };
import manifest from '../src/extension/meta/oclif.manifest.json' with { type: 'json' };
import shortDescriptions from './short-descriptions.json' with { type: 'json' };
import fs from 'node:fs/promises';

/**
 * Map used to match the root prefix of a
 * command to the context value of the menu item
 * that should be used to group the command in the menu.
 *
 * Adding items here will automatically add the
 * command to the menu and group it under the
 * specified context value.
 */
const prefixToContextValue = {
  apps: 'heroku:app',
  access: 'heroku:app',
  ci: 'heroku:app',
  domains: 'heroku:app',
  drains: 'heroku:app',
  features: 'heroku:app',
  labs: 'heroku:app',
  release: 'heroku:app',
  buildpacks: 'heroku:app',
  webhooks: 'heroku:app',

  ps: 'heroku:formation',
  'ps:stop': 'heroku:dyno',
  'ps:start': 'heroku:dyno',
  'ps:restart': 'heroku:dyno',
  pg: 'heroku:addon:heroku-postgresql',
  redis: 'heroku:addon:heroku-redis',
  addons: 'heroku:addon',
  pipelines: 'heroku:pipeline',
  spaces: 'heroku:space',
  teams: 'heroku:team'
};

const prefxToForcedSubmenu = {
  access: 'Access',
  apps: 'App',
  buildpacks: 'Buildpacks',
  ci: 'Continuous integration',
  domains: 'Domains',
  drains: 'Drains',
  features: 'Features',
  labs: 'Labs',
  pg: 'PostgreSQL',
  redis: 'Key-value store',
  release: 'Release',
  webhooks: 'Webhooks'
};

const commandRegistryNamePrefix = 'heroku:user';
/**
 * Map of menu items
 */
const menuItemMap = new Map();
/**
 * Map of submenus
 */
const submenuMap = new Map();
/**
 * Retain the exiting menu items.
 * Keys generated by this script overwrite
 * existing values
 */
for (const menuItem of pjson.contributes.menus['view/item/context']) {
  const { command, group } = menuItem;
  if (command && !command.startsWith(commandRegistryNamePrefix)) {
    menuItemMap.set(`${command}:${group}`, menuItem);
  }
}
delete pjson.contributes.menus['view/item/context'];
/**
 * Object of menu items belonging to
 * a submenu. This may contain nested
 * submenu structures.
 */
const submenuItemMap = {};
/**
 * Retain the exiting submenus.
 * Keys generated by this script overwrite
 * existing values
 */
for (const submenuName in pjson.contributes.menus) {
  if (submenuName === 'view/item/context' || submenuName.startsWith(commandRegistryNamePrefix)) {
    continue;
  }
  const submenu = pjson.contributes.menus[submenuName];
  submenuItemMap[submenuName] = submenu;
}
delete pjson.contributes.menus;
/**
 * Map of user facing commannds.
 * All commands in the oclif.manifest.json
 * are included.
 */
const commandMap = new Map();
/**
 * Perserve existing commands. Keys generated
 * by this script overwrite existing values
 */
for (const command of pjson.contributes.commands) {
  const { command: cmd } = command;
  if (cmd.startsWith(commandRegistryNamePrefix)) {
    continue;
  }
  commandMap.set(cmd, command);
}
delete pjson.contributes.commands;

const menuItemsByCommand = {};
const exclusionsFromRootSubmenus = {};
/**
 * Iterates the commands in the oclif.manifest.json
 * and generates the menu items and submenus for the
 * commands.
 */
for (let commandId in manifest.commands) {
  const { args, flags } = manifest.commands[commandId];
  if (args?.app && !args.app.required) {
    console.log('arg', commandId);
  }
  if (flags?.app && !flags.app.required) {
    console.log('flag', commandId);
  }
  if (!shortDescriptions[commandId]) {
    continue;
  }

  // Split the command topic at the colon
  // topics with a depth of 3 or more
  // will be placd in a submenu
  const parts = commandId.split(':');
  const rootPrefix = parts[0];
  // This key is used to register the command
  // in vscode and map the menu item to the command.
  const commandKey = `${commandRegistryNamePrefix}:${commandId}`;

  // All commands in the manifest are added.
  commandMap.set(commandKey, {
    command: commandKey,
    category: `Heroku ${rootPrefix}`,
    title: shortDescriptions[commandId] ?? ''
  });

  // The context value
  // @see https://code.visualstudio.com/api/references/vscode-api#TreeItem
  let contextValue;
  let idx = parts.length + 1;
  while (idx--) {
    const prefix = parts.slice(0, idx).join(':');
    if (!prefixToContextValue[prefix]) {
      continue;
    }
    contextValue = prefixToContextValue[prefix];
    break;
  }
  if (!contextValue) {
    continue;
  }

  menuItemsByCommand[commandKey] = {
    command: commandKey,
    group: parts.slice(0, parts.length - 1).join(':'),
    when: `viewItem =~ /^(${contextValue})/`
  };

  // Build the submenu for items with a topic depth of 2+
  // unless specified in the prefxToForcedSubmenu.
  let k = parts.length;
  let j = prefxToForcedSubmenu[rootPrefix] ? 1 : 2;
  while (k-- > j) {
    const prefix = parts.slice(0, parts.length - 1).join(':');
    const parentPrefix = parts.slice(0, k - 1).join(':');
    const part = parts[k - 1];

    const submenuLabel = prefxToForcedSubmenu[part] ?? part.slice(0, 1).toUpperCase() + part.slice(1);
    const submenuKey = `${commandRegistryNamePrefix}:${prefix}`;
    const parentSubmenuKey = `${commandRegistryNamePrefix}:${parentPrefix}`;

    if (k !== j && (parts.length > 3 || prefxToForcedSubmenu[parentPrefix])) {
      const parentSubMenu = submenuItemMap[parentSubmenuKey] || [];
      if (!parentSubMenu.some((p) => p.submenu === submenuKey)) {
        parentSubMenu.push({ submenu: submenuKey });
        exclusionsFromRootSubmenus[submenuKey] = true;
      }
      submenuItemMap[parentSubmenuKey] = parentSubMenu;
    }
    const submenu = submenuItemMap[submenuKey] || [];
    if (submenuMap.has(submenuKey)) {
      continue;
    }
    submenuMap.set(submenuKey, {
      id: submenuKey,
      label: submenuLabel
    });
    submenuItemMap[submenuKey] = submenu;
  }
}

for (const [key] of commandMap) {
  if (!menuItemsByCommand[key]) {
    continue;
  }
  if (submenuItemMap[key]) {
    // root item, add a delineator
    const rootMenuItem = menuItemsByCommand[key];
    rootMenuItem.group = `aaa${rootMenuItem.group}`;
    submenuItemMap[key].push(menuItemsByCommand[key]);
  } else {
    const parts = key.split(':');
    const parentSubmenuKey = parts.slice(0, parts.length - 1).join(':');
    if (submenuItemMap[parentSubmenuKey]) {
      submenuItemMap[parentSubmenuKey].push(menuItemsByCommand[key]);
    } else {
      menuItemMap.set(key, menuItemsByCommand[key]);
    }
  }
}

pjson.contributes.menus = submenuItemMap;
pjson.contributes.commands = Array.from(commandMap.values());
pjson.contributes.menus['view/item/context'] = Array.from(menuItemMap.values());
submenuMap.forEach((value, key) => {
  if (!exclusionsFromRootSubmenus[key]) {
    pjson.contributes.menus['view/item/context'].push({
      submenu: key
    });
  }
});
pjson.contributes.submenus = Array.from(submenuMap.values());
await fs.writeFile('package.json', JSON.stringify(pjson, null, 2));
